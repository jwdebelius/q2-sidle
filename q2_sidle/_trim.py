import hashlib
import warnings

import biom
import dask
import numpy as np
import pandas as pd

from q2_sidle._utils import (_setup_dask_client, 
                             _convert_generator_to_seq_block,
                             _convert_generator_to_delayed_seq_block, 
                             _convert_seq_block_to_dna_fasta_format,
                             degen_reps,
                             )

from q2_types.feature_data import (DNAFASTAFormat,
                                   DNAIterator, 
                                   )

def trim_dada2_posthoc(table: biom.Table, 
                       representative_sequences: pd.Series, 
                       trim_length:int=0, 
                       hashed_feature_ids:bool=True
                       ) -> (biom.Table, DNAFASTAFormat):
    """
    Trims ASVs generated by DADA2 to a standard length

    Parameters
    ----------
    table : biom.Table
        The feature table
    representative_sequences: DNAFASTAFormat
        The sequences which correspond to the ASV table
    trim_length  : int
        The length to trim the ASVS. If the length is 0, the minimum sequence
        length will be used.
    hash_feature_ids: bool
        Whether feature and sequence IDs should be hashed.
    """

    # Trims the sequences
    seq_length = representative_sequences.apply(lambda x: len(x))

    if trim_length == 0:
        trim_length = seq_length.min()
    
    if (seq_length < trim_length).any():
        warnings.warn("There are ASVs shorter than the trim length. "
                          "These sequences will be discarded.", UserWarning)
    rep_seqs = representative_sequences.astype(str)
    rep_seqs = rep_seqs.loc[seq_length >= trim_length].copy()
    rep_seqs = pd.DataFrame(data=[rep_seqs.apply(lambda x: x[:trim_length])],
                            index=['sequence']
                            ).T

    # Collapses the table based on the trimmed sequences
    table.filter(lambda v, id_, md: id_ in rep_seqs.index,
                 axis='observation',
                 inplace=True
                 )
    table.add_metadata(
        rep_seqs.loc[table.ids(axis='observation')].to_dict(orient='index'),
        axis='observation')

    table2 = table.collapse(lambda id_, md: md['sequence'], 
                            norm=False,
                            axis='observation')

    seqs2 = rep_seqs.drop_duplicates()['sequence'].copy()

    if hashed_feature_ids:
        table2.update_ids(
            {seq_: _hash_seq(seq_) for seq_ in table2.ids(axis='observation')},
            axis='observation',
            inplace=True
            )
        seqs2.rename({id_: _hash_seq(seq_) for id_, seq_ in seqs2.items()}, 
                    inplace=True)
    else:
        seqs2.rename({id_: seq_ for id_, seq_ in seqs2.items()}, 
                    inplace=True)

    seqs2 = _convert_seq_block_to_dna_fasta_format(
        [seqs2.apply(lambda x: pd.Series(list(x)))]
        )

    return table2, seqs2


def _hash_seq(x):
    return hashlib.md5(x.encode()).hexdigest()

